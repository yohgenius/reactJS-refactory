["7cf88e1e007a71e2621f54b4c686c46b56a6758d","cda4236e29f3bad31b6fe12cd840a75deef79481",["fbjs/lib/invariant"],[40],{"version":3,"sources":["/firstPro/node_modules/react-native/Libraries/Lists/VirtualizeUtils.js"],"names":["invariant","require","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule VirtualizeUtils\n * @flow\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  itemCount: number,\n  getFrameMetrics: (index: number) => {length: number, offset: number},\n): Array<number> {\n  const out = [];\n  for (let ii = 0; ii < itemCount; ii++) {\n    const frame = getFrameMetrics(ii);\n    const trailingOffset = frame.offset + frame.length;\n    for (let kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        if (kk === offsets.length - 1) {\n          invariant(\n            out.length === offsets.length,\n            'bad offsets input, should be in increasing order ' + JSON.stringify(offsets)\n          );\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nfunction newRangeCount(\n  prev: {first: number, last: number},\n  next: {first: number, last: number},\n): number {\n  return (next.last - next.first + 1) -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first)\n    );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nfunction computeWindowedRenderLimits(\n  props: {\n    data: any,\n    getItemCount: (data: any) => number,\n    maxToRenderPerBatch: number,\n    windowSize: number,\n  },\n  prev: {first: number, last: number},\n  getFrameMetricsApprox: (index: number) => {length: number, offset: number},\n  scrollMetrics: {dt: number, offset: number, velocity: number, visibleLength: number},\n): {first: number, last: number} {\n  const {data, getItemCount, maxToRenderPerBatch, windowSize} = props;\n  const itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  const {offset, velocity, visibleLength} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference = velocity > 1 ? 'after' : (velocity < -1 ? 'before' : 'none');\n\n  const overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  // Find the indices that correspond to the items at the render boundaries we're targetting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props.getItemCount(props.data),\n    getFrameMetricsApprox,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? (itemCount - 1) : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (firstShouldIncrement &&\n        !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement &&\n        !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(\n    last >= first &&\n    first >= 0 && last < itemCount &&\n    first >= overscanFirst && last <= overscanLast &&\n    first <= visible.first && last >= visible.last\n  )) {\n    throw new Error('Bad window calculation ' +\n      JSON.stringify({first, last, itemCount, overscanFirst, overscanLast, visible}));\n  }\n  return {first, last};\n}\n\nconst VirtualizeUtils = {\n  computeWindowedRenderLimits,\n  elementsThatOverlapOffsets,\n  newRangeCount,\n};\n\nmodule.exports = VirtualizeUtils;\n"]}]