["b6e10b002138cad4127a1edccf4e7217f4c8fcbe","3d5e4f6ea52932b9c0b5825f957df0153a8d8ea1",["Systrace","fbjs/lib/invariant","fbjs/lib/performanceNow","fbjs/lib/warning","JSTimers","NativeModules"],[39,77,129,179,2684,3481,3699,4596],{"version":3,"sources":["/firstPro/node_modules/react-native/Libraries/Core/Timers/JSTimersExecution.js"],"names":["Systrace","require","invariant","performanceNow","warning","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","hasEmittedTimeDriftWarning","JSTimersExecution","GUID","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","Map","identifiers","errors","callTimer","timerID","frameTime","didTimeout","timerIndex","indexOf","type","callback","console","error","__DEV__","identifier","beginEvent","methodName","_clearIndex","timeRemaining","Math","max","e","push","endEvent","callTimers","length","i","errorCount","ii","setTimeout","bind","callIdleCallbacks","passIdleCallbacks","slice","Timing","setSendIdleEvents","forEach","callImmediatesPass","passImmediates","callImmediates","emitTimeDriftWarning","warningMessage","warn","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule JSTimersExecution\n * @flow\n */\n'use strict';\n\nconst Systrace = require('Systrace');\n\nconst invariant = require('fbjs/lib/invariant');\nconst performanceNow = require('fbjs/lib/performanceNow');\nconst warning = require('fbjs/lib/warning');\n\n// These timing contants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nlet hasEmittedTimeDriftWarning = false;\n\nexport type JSTimerType =\n  'setTimeout' |\n  'setInterval' |\n  'requestAnimationFrame' |\n  'setImmediate' |\n  'requestIdleCallback';\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimersExecution = {\n  GUID: 1,\n\n  // Parallel arrays\n  callbacks: ([] : Array<?Function>),\n  types: ([] : Array<?JSTimerType>),\n  timerIDs: ([] : Array<?number>),\n  immediates: [],\n  requestIdleCallbacks: [],\n  requestIdleCallbackTimeouts: (new Map() : Map<number, number>),\n  identifiers: ([] : Array<null | {methodName: string}>),\n\n  errors: (null : ?Array<Error>),\n\n  /**\n   * Calls the callback associated with the ID. Also unregister that callback\n   * if it was a one time timer (setTimeout), and not unregister it if it was\n   * recurring (setInterval).\n   */\n  callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n    warning(\n      timerID <= JSTimersExecution.GUID,\n      'Tried to call timer with ID %s but no such timer exists.',\n      timerID\n    );\n\n    // timerIndex of -1 means that no timer with that ID exists. There are\n    // two situations when this happens, when a garbage timer ID was given\n    // and when a previously existing timer was deleted before this callback\n    // fired. In both cases we want to ignore the timer id, but in the former\n    // case we warn as well.\n    const timerIndex = JSTimersExecution.timerIDs.indexOf(timerID);\n    if (timerIndex === -1) {\n      return;\n    }\n\n    const type = JSTimersExecution.types[timerIndex];\n    const callback = JSTimersExecution.callbacks[timerIndex];\n    if (!callback || !type) {\n      console.error('No callback found for timerID ' + timerID);\n      return;\n    }\n\n    if (__DEV__) {\n      const identifier = JSTimersExecution.identifiers[timerIndex] || {};\n      Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n    }\n\n    // Clear the metadata\n    if (type === 'setTimeout' || type === 'setImmediate' ||\n        type === 'requestAnimationFrame' || type === 'requestIdleCallback') {\n      JSTimersExecution._clearIndex(timerIndex);\n    }\n\n    try {\n      if (type === 'setTimeout' || type === 'setInterval' ||\n          type === 'setImmediate') {\n        callback();\n      } else if (type === 'requestAnimationFrame') {\n        callback(performanceNow());\n      } else if (type === 'requestIdleCallback') {\n        callback({\n          timeRemaining: function() {\n            // TODO: Optimisation: allow running for longer than one frame if\n            // there are no pending JS calls on the bridge from native. This\n            // would require a way to check the bridge queue synchronously.\n            return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n          },\n          didTimeout: !!didTimeout,\n        });\n      } else {\n        console.error('Tried to call a callback with invalid type: ' + type);\n      }\n    } catch (e) {\n      // Don't rethrow so that we can run all timers.\n      if (!JSTimersExecution.errors) {\n        JSTimersExecution.errors = [e];\n      } else {\n        JSTimersExecution.errors.push(e);\n      }\n    }\n\n    if (__DEV__) {\n      Systrace.endEvent();\n    }\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers(timerIDs: [number]) {\n    invariant(\n      timerIDs.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.'\n    );\n\n    JSTimersExecution.errors = null;\n    for (let i = 0; i < timerIDs.length; i++) {\n      JSTimersExecution.callTimer(timerIDs[i], 0);\n    }\n\n    const errors = JSTimersExecution.errors;\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          require('JSTimers').setTimeout(\n            ((error) => { throw error; }).bind(null, errors[ii]),\n            0\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n\n    JSTimersExecution.errors = null;\n    if (JSTimersExecution.requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = JSTimersExecution.requestIdleCallbacks.slice();\n      JSTimersExecution.requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        JSTimersExecution.callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (JSTimersExecution.requestIdleCallbacks.length === 0) {\n      const { Timing } = require('NativeModules');\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (JSTimersExecution.errors) {\n      JSTimersExecution.errors.forEach((error) =>\n        require('JSTimers').setTimeout(() => { throw error; }, 0)\n      );\n    }\n  },\n\n  /**\n   * Performs a single pass over the enqueued immediates. Returns whether\n   * more immediates are queued up (can be used as a condition a while loop).\n   */\n  callImmediatesPass() {\n    if (__DEV__) {\n      Systrace.beginEvent('JSTimersExecution.callImmediatesPass()');\n    }\n\n    // The main reason to extract a single pass is so that we can track\n    // in the system trace\n    if (JSTimersExecution.immediates.length > 0) {\n      const passImmediates = JSTimersExecution.immediates.slice();\n      JSTimersExecution.immediates = [];\n\n      // Use for loop rather than forEach as per @vjeux's advice\n      // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n      for (let i = 0; i < passImmediates.length; ++i) {\n        JSTimersExecution.callTimer(passImmediates[i], 0);\n      }\n    }\n\n    if (__DEV__) {\n      Systrace.endEvent();\n    }\n    return JSTimersExecution.immediates.length > 0;\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    JSTimersExecution.errors = null;\n    while (JSTimersExecution.callImmediatesPass()) {}\n    if (JSTimersExecution.errors) {\n      JSTimersExecution.errors.forEach((error) =>\n        require('JSTimers').setTimeout(() => { throw error; }, 0)\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n\n  _clearIndex(i: number) {\n    JSTimersExecution.timerIDs[i] = null;\n    JSTimersExecution.callbacks[i] = null;\n    JSTimersExecution.types[i] = null;\n    JSTimersExecution.identifiers[i] = null;\n  },\n};\n\nmodule.exports = JSTimersExecution;\n"]}]