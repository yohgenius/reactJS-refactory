["553c5f275e2ec29f0ac6d76093ee0f375b7cbf4c","8156df43cbf637a9b2efbd5e0cdb1ee24ac0f985",["react-native","./AV"],[3931,3967],{"version":3,"sources":["/firstPro/node_modules/expo/src/Audio.js"],"names":["setIsEnabledAsync","setAudioModeAsync","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3","RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN","RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW","RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM","RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH","RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","android","extension","outputFormat","audioEncoder","sampleRate","numberOfChannels","bitRate","ios","audioQuality","linearPCMBitDepth","linearPCMIsBigEndian","linearPCMIsFloat","RECORDING_OPTIONS_PRESET_LOW_QUALITY","INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS","INTERRUPTION_MODE_IOS_DO_NOT_MIX","INTERRUPTION_MODE_IOS_DUCK_OTHERS","INTERRUPTION_MODE_ANDROID_DO_NOT_MIX","INTERRUPTION_MODE_ANDROID_DUCK_OTHERS","_enabled","_recorderExists","_DISABLED_ERROR","Error","_isValueValid","value","validValues","filter","validValue","length","_findMissingKeys","object","requiredKeys","requiredKey","ExponentAV","setAudioIsEnabled","mode","missingKeys","JSON","stringify","interruptionModeIOS","interruptionModeAndroid","allowsRecordingIOS","playsInSilentModeIOS","shouldDuckAndroid","setAudioMode","Sound","_statusUpdateCallback","status","_callCallbackForNewStatus","_setStatusUpdateCallback","_errorCallback","error","_loaded","_key","getStatusAsync","_performOperationAndHandleStatusAsync","getStatusForSound","_loading","_callback","operation","setStatusUpdateCallbackForSound","callback","source","initialStatus","downloadFirst","loading","uri","fullInitialStatus","Promise","resolve","reject","loadSuccess","key","setErrorCallbackForSound","loadError","loadForSound","bind","unloadForSound","setStatusForSound","create","sound","setCallback","loadAsync","prototype","Recording","_pollingLoop","_canRecord","_progressUpdateTimeoutVariable","setTimeout","_progressUpdateIntervalMillis","getAudioRecordingStatus","_isDoneRecording","canRecord","isDoneRecording","durationMillis","_finalDurationMillis","_uri","_options","clearTimeout","_disablePolling","_enablePollingIfNecessaryAndPossible","progressUpdateIntervalMillis","options","extensionRegex","test","toString","prepareAudioRecorder","startAudioRecording","pauseAudioRecording","stopAudioRecording","stopStatus","unloadAudioRecorder"],"mappings":"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","sourcesContent":["// @flow\n\nimport { NativeModules } from 'react-native';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  _COMMON_AV_PLAYBACK_METHODS,\n  _getURIAndFullInitialStatusForLoadAsync,\n  _throwErrorIfValuesOutOfBoundsInStatus,\n  _getUnloadedStatus,\n  type PlaybackSource,\n  type PlaybackStatus,\n  type PlaybackStatusToSet,\n} from './AV';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string,\n    outputFormat: number,\n    audioEncoder: number,\n    sampleRate?: number,\n    numberOfChannels?: number,\n    bitRate?: number,\n    maxFileSize?: number,\n  },\n  ios: {\n    extension: string,\n    outputFormat?: string | number,\n    audioQuality: number,\n    sampleRate: number,\n    numberOfChannels: number,\n    bitRate: number,\n    bitRateStrategy?: number,\n    bitDepthHint?: number,\n    linearPCMBitDepth?: number,\n    linearPCMIsBigEndian?: boolean,\n    linearPCMIsFloat?: boolean,\n  },\n};\n\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS = 6;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as well?\nexport type RecordingStatus =\n  | {\n      canRecord: false,\n      isDoneRecording: false,\n    }\n  | {\n      canRecord: true,\n      isRecording: boolean,\n      durationMillis: number,\n    }\n  | {\n      canRecord: false,\n      isDoneRecording: true,\n      durationMillis: number,\n    };\n\nexport type AudioMode = {\n  allowsRecordingIOS: boolean,\n  interruptionModeIOS: number,\n  playsInSilentModeIOS: boolean,\n  interruptionModeAndroid: boolean,\n  shouldDuckAndroid: boolean,\n};\n\nexport const INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;\nexport const INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;\n\nexport const INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2;\n\nlet _enabled: boolean = true;\nlet _recorderExists: boolean = false;\nconst _DISABLED_ERROR: Error = new Error(\n  'Cannot complete operation because audio is not enabled.'\n);\n\n// Returns true if value is in validValues, and false if not.\nconst _isValueValid = (value: any, validValues: Array<any>): boolean => {\n  return validValues.filter(validValue => validValue === value).length > 0;\n};\n\n// Returns array of missing keys in object. Returns an empty array if no missing keys are found.\nconst _findMissingKeys = (\n  object: Object,\n  requiredKeys: Array<any>\n): Array<any> => {\n  return requiredKeys.filter(requiredKey => !(requiredKey in object));\n};\n\nexport async function setIsEnabledAsync(value: boolean): Promise<void> {\n  _enabled = value;\n  await NativeModules.ExponentAV.setAudioIsEnabled(value);\n  // TODO : We immediately pause all players when disabled, but we do not resume all shouldPlay\n  // players when enabled. Perhaps for completeness we should allow this; the design of the\n  // enabling API is for people to enable / disable this audio library, but I think that it should\n  // intuitively also double as a global pause/resume.\n}\n\nexport async function setAudioModeAsync(mode: AudioMode): Promise<void> {\n  const missingKeys = _findMissingKeys(mode, [\n    'allowsRecordingIOS',\n    'interruptionModeIOS',\n    'playsInSilentModeIOS',\n    'interruptionModeAndroid',\n    'shouldDuckAndroid',\n  ]);\n  if (missingKeys.length > 0) {\n    throw new Error(\n      `Audio mode attempted to be set without the required keys: ${JSON.stringify(\n        missingKeys\n      )}`\n    );\n  }\n  if (\n    !_isValueValid(mode.interruptionModeIOS, [\n      INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n      INTERRUPTION_MODE_IOS_DO_NOT_MIX,\n      INTERRUPTION_MODE_IOS_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (\n    !_isValueValid(mode.interruptionModeAndroid, [\n      INTERRUPTION_MODE_ANDROID_DO_NOT_MIX,\n      INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  await NativeModules.ExponentAV.setAudioMode(mode);\n}\n\nexport class Sound {\n  _loaded: boolean;\n  _loading: boolean;\n  _key: number;\n  _callback: ?(status: PlaybackStatus) => void;\n\n  constructor() {\n    this._loaded = false;\n    this._loading = false;\n    this._key = -1;\n    this._callback = null;\n  }\n\n  static create = async (\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    callback: ?(status: PlaybackStatus) => void = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound, status: PlaybackStatus }> => {\n    const sound: Sound = new Sound();\n    sound.setCallback(callback);\n    const status: PlaybackStatus = await sound.loadAsync(\n      source,\n      initialStatus,\n      downloadFirst\n    );\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callCallbackForNewStatus(status: PlaybackStatus) {\n    if (this._callback != null) {\n      this._callback(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<PlaybackStatus>\n  ): Promise<PlaybackStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this._loaded) {\n      const status = await operation();\n      this._callCallbackForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  _statusUpdateCallback = (status: PlaybackStatus) => {\n    this._callCallbackForNewStatus(status);\n    this._setStatusUpdateCallback(); // Callbacks are only called once and then released.\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._callback).\n  _setStatusUpdateCallback() {\n    if (this._loaded) {\n      NativeModules.ExponentAV.setStatusUpdateCallbackForSound(\n        this._key,\n        this._statusUpdateCallback\n      );\n    }\n  }\n\n  _errorCallback = (error: string) => {\n    this._loaded = false;\n    this._key = -1;\n    this._callCallbackForNewStatus(_getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call the callback as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<PlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: PlaybackStatus = _getUnloadedStatus();\n    this._callCallbackForNewStatus(status);\n    return status;\n  };\n\n  setCallback(callback: ?(status: PlaybackStatus) => void) {\n    this._callback = callback;\n    this.getStatusAsync();\n  }\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<PlaybackStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this.loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const {\n        uri,\n        fullInitialStatus,\n      } = await _getURIAndFullInitialStatusForLoadAsync(\n        source,\n        initialStatus,\n        downloadFirst\n      );\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise(\n        function(resolve, reject) {\n          const loadSuccess = (key: number, status: PlaybackStatus) => {\n            this._key = key;\n            this._loaded = true;\n            this._loading = false;\n            NativeModules.ExponentAV.setErrorCallbackForSound(\n              this._key,\n              this._errorCallback\n            );\n            this._setStatusUpdateCallback();\n            this._callCallbackForNewStatus(status);\n            resolve(status);\n          };\n          const loadError = (error: string) => {\n            this._loading = false;\n            reject(new Error(error));\n          };\n          NativeModules.ExponentAV.loadForSound(\n            uri,\n            fullInitialStatus,\n            loadSuccess,\n            loadError\n          );\n        }.bind(this)\n      );\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<PlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = -1;\n      const status = await NativeModules.ExponentAV.unloadForSound(key);\n      this._callCallbackForNewStatus(status);\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls the callback.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: PlaybackStatusToSet): Promise<PlaybackStatus> {\n    _throwErrorIfValuesOutOfBoundsInStatus(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  // Additional convenience methods on top of setStatusAsync are set via _COMMON_AV_PLAYBACK_METHODS.\n  playAsync: () => Promise<PlaybackStatus>;\n  playFromPositionAsync: (positionMillis: number) => Promise<PlaybackStatus>;\n  pauseAsync: () => Promise<PlaybackStatus>;\n  stopAsync: () => Promise<PlaybackStatus>;\n  setPositionAsync: (positionMillis: number) => Promise<PlaybackStatus>;\n  setRateAsync: (\n    rate: number,\n    shouldCorrectPitch: boolean\n  ) => Promise<PlaybackStatus>;\n  setVolumeAsync: (volume: number) => Promise<PlaybackStatus>;\n  setIsMutedAsync: (isMuted: boolean) => Promise<PlaybackStatus>;\n  setIsLoopingAsync: (isLooping: boolean) => Promise<PlaybackStatus>;\n  setProgressUpdateIntervalAsync: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<PlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, _COMMON_AV_PLAYBACK_METHODS);\n\nexport class Recording {\n  _canRecord: boolean;\n  _isDoneRecording: boolean;\n  _finalDurationMillis: number;\n  _uri: ?string;\n  _callback: ?(status: RecordingStatus) => void;\n  _progressUpdateTimeoutVariable: ?number;\n  _progressUpdateIntervalMillis: number;\n  _options: ?RecordingOptions;\n\n  constructor() {\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n  }\n\n  // Internal methods\n\n  _pollingLoop = () => {\n    if (_enabled && this._canRecord && this._callback != null) {\n      this.getStatusAsync(); // Automatically calls this._callback.\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      );\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (_enabled && this._canRecord && this._callback != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callCallbackForNewStatus(status: RecordingStatus) {\n    if (this._callback != null) {\n      this._callback(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this._canRecord) {\n      const status = await operation();\n      this._callCallbackForNewStatus(status);\n      return status;\n    } else {\n      throw new Error(\n        'Cannot complete operation because this recorder is not ready to record.'\n      );\n    }\n  }\n\n  // Note that all calls automatically call the callback as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls the callback.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getAudioRecordingStatus()\n      );\n    }\n    const status: RecordingStatus = this._isDoneRecording\n      ? {\n          canRecord: false,\n          isDoneRecording: true,\n          durationMillis: this._finalDurationMillis,\n        }\n      : {\n          canRecord: false,\n          isDoneRecording: false,\n        };\n    this._callCallbackForNewStatus(status);\n    return status;\n  };\n\n  setCallback(callback: ?(status: RecordingStatus) => void) {\n    this._callback = callback;\n    if (callback == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n\n    if (_recorderExists) {\n      throw new Error(\n        'Only one Recording object can be prepared at a given time.'\n      );\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error(\n        'This Recording object is done recording; you must make a new one.'\n      );\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(\n        `Your file extensions must match ${extensionRegex.toString()}.`\n      );\n    }\n\n    if (!this._canRecord) {\n      const {\n        uri,\n        status,\n      }: {\n        uri: string,\n        status: Object, // status is of type RecordingStatus, but without the canRecord field populated.\n      } = await NativeModules.ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n      this._callCallbackForNewStatus(status);\n      this._enablePollingIfNecessaryAndPossible();\n      return status;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.startAudioRecording()\n    );\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.pauseAudioRecording()\n    );\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      throw new Error('Cannot unload a Recording that has not been prepared.');\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const stopStatus: Object = await NativeModules.ExponentAV.stopAudioRecording();\n    this._finalDurationMillis = stopStatus.durationMillis;\n    this._disablePolling();\n\n    await NativeModules.ExponentAV.unloadAudioRecorder();\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    _recorderExists = false;\n    return this.getStatusAsync(); // Automatically calls the callback for the final state.\n  }\n\n  // Read API\n\n  getURI(): ?string {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    callback: ?(status: PlaybackStatus) => void = null\n  ): Promise<{ sound: Sound, status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error(\n        'Cannot create sound when the Recording has not finished!'\n      );\n    }\n    // $FlowFixMe: Flow can't distinguish between this literal and Asset\n    return Sound.create({ uri: this._uri }, initialStatus, callback, false);\n  }\n}\n"]}]